	
FORCEINLINE FloatStore<2>::FloatStore(DX::FXMVECTOR v) noexcept {
	x = DX::XMVectorGetX(v);
	y = DX::XMVectorGetY(v);
}

FORCEINLINE float &FloatStore<2>::operator[](size_t n) noexcept {
	assert(n < 2);
	return reinterpret_cast<float *>(this)[n];
}

FORCEINLINE float FloatStore<2>::operator[](size_t n) const noexcept {
	assert(n < 2);
	return reinterpret_cast<const float *>(this)[n];
}

FORCEINLINE std::ostream &operator<<(std::ostream &os, const FloatStore<2> &v) noexcept {
 	os << '(' << v.x << ", " << v.y << ')';
 	return os;
}

FORCEINLINE FloatStore<2> FloatStore<2>::operator-() const noexcept {
	return FloatStore(-x, -y);
}

FORCEINLINE FloatStore<2>::operator DX::XMVECTOR() const noexcept {
	return DX::XMVectorSet(x, y, 0.f, 0.f);
}

template<typename T> requires(std::is_convertible_v<T, float>)
FORCEINLINE FloatStore<2>::FloatStore(T v) noexcept : DX::XMFLOAT2(static_cast<float>(v), static_cast<float>(v)) {
}

template<typename T1, typename T2>
requires(std::is_convertible_v<T1, float> && std::is_convertible_v<T2, float>)
FORCEINLINE FloatStore<2>::FloatStore(T1 x, T2 y) noexcept : DX::XMFLOAT2(float(x), float(y)) {
}

/////////////////////////////////////////////////////////////////////////////////////////////////


FORCEINLINE FloatStore<3>::FloatStore(DX::FXMVECTOR v) noexcept {
	x = DX::XMVectorGetX(v);
	y = DX::XMVectorGetY(v);
	z = DX::XMVectorGetZ(v);
}

template<typename T> requires(std::is_convertible_v<T, float>)
FORCEINLINE FloatStore<3>::FloatStore(T v)
: XMFLOAT3(float(v), float(v), float(v)) {

}
template<typename T1, typename T2, typename T3>
requires(std::is_convertible_v<T1, float> && std::is_convertible_v<T2, float> &&
std::is_convertible_v<T3, float>)
FORCEINLINE FloatStore<3>::FloatStore(T1 x, T2 y, T3 z) noexcept
: DX::XMFLOAT3(float(x), float(y), float(z)) {

}

template<size_t N> requires(N <= 3)
FORCEINLINE FloatStore<3>::operator FloatStore<N> &() noexcept {
	return reinterpret_cast<FloatStore<N> &>(*this);
}

template<size_t N> requires(N <= 3)
FORCEINLINE FloatStore<3>::operator const FloatStore<N> &() const noexcept {
	return reinterpret_cast<const FloatStore<N> &>(*this);
}

FORCEINLINE float &FloatStore<3>::operator[](size_t n) noexcept {
	assert(n < 3);
	return reinterpret_cast<float *>(this)[n];
}

FORCEINLINE float FloatStore<3>::operator[](size_t n) const noexcept {
	assert(n < 3);
	return reinterpret_cast<const float *>(this)[n];
}

FORCEINLINE FloatStore<3>::FloatStore(const DX::XMVECTORF32 & color) noexcept
: FloatStore(color.operator DirectX::XMVECTOR()) {
}

FORCEINLINE std::ostream &operator<<(std::ostream &os, const FloatStore<3> &v) noexcept {
	os << '(' << v.x << ", " << v.y << ", " << v.z << ')';
	return os;
}

FloatStore<3> FloatStore<3>::operator-() const noexcept {
	return FloatStore(-x, -y, -z);
}

FORCEINLINE FloatStore<3>::operator DX::XMVECTOR() const noexcept {
	return DX::XMVectorSet(x, y, z, 0.f);
}

/////////////////////////////////////////////////////////////////////////////////////////////////


FORCEINLINE FloatStore<4>::FloatStore(DX::FXMVECTOR v) noexcept {
	x = DX::XMVectorGetX(v);
	y = DX::XMVectorGetY(v);
	z = DX::XMVectorGetZ(v);
	w = DX::XMVectorGetW(v);
}

FORCEINLINE FloatStore<4>::FloatStore(const FloatStore<3> &f3, float w) noexcept : DX::XMFLOAT4(f3.x, f3.y, f3.z, w) {
}

FORCEINLINE float &FloatStore<4>::operator[](size_t n) noexcept {
	assert(n < 4);
	return reinterpret_cast<float *>(this)[n];
}

FORCEINLINE float FloatStore<4>::operator[](size_t n) const noexcept {
	assert(n < 4);
	return reinterpret_cast<const float *>(this)[n];
}

FORCEINLINE FloatStore<4>::FloatStore(const DX::XMVECTORF32 & color) noexcept
: FloatStore(color.operator DirectX::XMVECTOR()) {
}

FORCEINLINE std::ostream &operator<<(std::ostream &os, const FloatStore<4> &v) noexcept {
	os << '(' << v.x << ", " << v.y << ", " << v.z << ", " << v.w << ')';
	return os;
}

FORCEINLINE FloatStore<4> FloatStore<4>::operator-() const noexcept {
	return FloatStore(-x, -y, -z, -w);
}

FORCEINLINE FloatStore<4>::operator DX::XMVECTOR() const noexcept {
	return DX::XMLoadFloat4(this);
}

template<typename T> requires(std::is_convertible_v<T, float>)
FORCEINLINE FloatStore<4>::FloatStore(T v) noexcept : DX::XMFLOAT4(float(v), float(v), float(v), float(v)) {
}

template<typename T1, typename T2, typename T3, typename T4>
	requires(std::is_convertible_v<T1, float> &&std::is_convertible_v<T2, float> &&
			std::is_convertible_v<T3, float> &&std::is_convertible_v<T4, float>)
FORCEINLINE FloatStore<4>::FloatStore(T1 x, T2 y, T3 z, T4 w) noexcept : DX::XMFLOAT4(float(x), float(y), float(z), float(w)) {
}

template<size_t N> requires(N <= 4)
FORCEINLINE FloatStore<4>::operator FloatStore<N> &() noexcept {
	return reinterpret_cast<FloatStore<N> &>(*this);
}

template<size_t N> requires(N <= 4)
FORCEINLINE FloatStore<4>::operator const FloatStore<N> &() const noexcept {
	return reinterpret_cast<const FloatStore<N> &>(*this);
}